'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initializeContext = initializeContext;
exports.mapRecord = mapRecord;
exports.mapId = mapId;
exports.matchId = matchId;
exports.castId = castId;
exports.under = under;
exports.parseBuffer = parseBuffer;

var _parseFloat = require('babel-runtime/core-js/number/parse-float');

var _parseFloat2 = _interopRequireDefault(_parseFloat);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _inflection = require('inflection');

var _inflection2 = _interopRequireDefault(_inflection);

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _settings = require('./settings');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function initializeContext(context, request) {
  var uriTemplate = this.uriTemplate;
  var methodMap = this.methodMap;
  var inputMethods = this.inputMethods;
  var recordTypes = this.recordTypes;
  var adapter = this.adapter;
  var keys = this.keys;
  var methods = this.methods;
  var _options = this.options;
  var inflectType = _options.inflectType;
  var inflectKeys = _options.inflectKeys;
  var _errors = this.errors;
  var NotAcceptableError = _errors.NotAcceptableError;
  var UnsupportedError = _errors.UnsupportedError;
  var NotFoundError = _errors.NotFoundError;

  // Initialize headers object.

  context.response.meta.headers = {};

  // According to the spec, if the media type is provided in the Accept
  // header, it should be included at least once without any media type
  // parameters.
  if (request.headers['accept'] && ~request.headers['accept'].indexOf(_settings.mediaType)) {
    var escapedMediaType = _settings.mediaType.replace(/[\+\.]/g, '\\$&');
    var mediaTypeRegex = new RegExp(escapedMediaType + '(?!;)', 'g');
    if (!request.headers['accept'].match(mediaTypeRegex)) throw new NotAcceptableError('The Accept header should contain' + 'at least one instance of the JSON media type without any' + 'media type parameters.');
  }

  var _context$request = context.request;
  var serializerInput = _context$request.serializerInput;
  var serializerOutput = _context$request.serializerOutput;
  var meta = _context$request.meta;

  var method = context.request.method = methodMap[request.method];

  // Not according to the spec but probably a good idea in practice, do not
  // allow a different media type for input.
  if (serializerInput !== serializerOutput && inputMethods.has(method)) throw new UnsupportedError('The media type of the input must be "' + _settings.mediaType + '".');

  // Decode URI Component only for the query string.
  var uriObject = uriTemplate.fromUri(request.url);

  if (!(0, _keys2.default)(uriObject).length && request.url.length > 1) throw new NotFoundError('Invalid URI.');

  context.request.uriObject = uriObject;

  context.request.type = uriObject.type ? inflectType ? _inflection2.default.singularize(uriObject.type) : uriObject.type : null;

  context.request.ids = uriObject.ids ? (Array.isArray(uriObject.ids) ? uriObject.ids : [uriObject.ids]).map(castId) : null;

  var _context$request2 = context.request;
  var type = _context$request2.type;
  var ids = _context$request2.ids;

  var fields = recordTypes[type];

  attachQueries.call(this, context);

  var relatedField = uriObject.relatedField;
  var relationship = uriObject.relationship;

  if (relationship) {
    if (relatedField !== _settings.reservedKeys.relationships) throw new NotFoundError('Invalid relationship URI.');

    // This is a little unorthodox, but POST and DELETE requests to a
    // relationship entity should be treated as updates.
    if (method === methods.create || method === methods.delete) {
      context.request.originalMethod = method;
      context.request.method = methods.update;
    }

    relatedField = relationship;
  }

  if (relatedField && inflectKeys) relatedField = _inflection2.default.camelize(under(relatedField), true);

  if (relatedField && (!(relatedField in fields) || !(keys.link in fields[relatedField]) || fields[relatedField][keys.denormalizedInverse])) throw new NotFoundError('The field "' + relatedField + '" is ' + ('not a link on the type "' + type + '".'));

  return relatedField ? adapter.find(type, ids, {
    // We only care about getting the related field.
    fields: (0, _defineProperty3.default)({}, relatedField, true)
  }, meta).then(function (records) {
    // Reduce the related IDs from all of the records into an array of
    // unique IDs.
    var relatedIds = [].concat((0, _toConsumableArray3.default)((records || []).reduce(function (ids, record) {
      var value = record[relatedField];

      if (Array.isArray(value)) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(value), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var id = _step.value;
            ids.add(id);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else ids.add(value);

      return ids;
    }, new _set2.default())));

    var relatedType = fields[relatedField][keys.link];

    // Copy the original type and IDs to temporary keys.
    context.request.relatedField = relatedField;
    context.request.relationship = Boolean(relationship);
    context.request.originalType = type;
    context.request.originalIds = ids;

    // Write the related info to the request, which should take
    // precedence over the original type and IDs.
    context.request.type = relatedType;
    context.request.ids = relatedIds;

    return context;
  }) : context;
}

/**
 * Internal function to map a record to JSON API format. It must be
 * called directly within the context of the serializer. Within this
 * function, IDs must be cast to strings, per the spec.
 */
function mapRecord(type, record) {
  var keys = this.keys;
  var options = this.options;
  var uriTemplate = this.uriTemplate;
  var recordTypes = this.recordTypes;

  var fields = recordTypes[type];
  var prefix = options.prefix;
  var inflectType = options.inflectType;
  var inflectKeys = options.inflectKeys;

  var clone = {};

  var id = record[keys.primary];

  clone[_settings.reservedKeys.type] = inflectType ? _inflection2.default.pluralize(type) : type;
  clone[_settings.reservedKeys.id] = id.toString();
  clone[_settings.reservedKeys.meta] = {};
  clone[_settings.reservedKeys.attributes] = {};
  clone[_settings.reservedKeys.relationships] = {};
  clone[_settings.reservedKeys.links] = (0, _defineProperty3.default)({}, _settings.reservedKeys.self, prefix + uriTemplate.fillFromObject({
    type: inflectType ? _inflection2.default.pluralize(type) : type,
    ids: id
  }));

  for (var field in record) {
    var _reservedKeys$links, _clone$reservedKeys$r;

    if (field === keys.primary) continue;

    var fieldDefinition = fields[field];
    var originalField = field;

    // Per the recommendation, dasherize keys.
    if (inflectKeys) field = _inflection2.default.transform(field, ['underscore', 'dasherize']);

    // Handle meta/attributes.
    if (!fieldDefinition || fieldDefinition[keys.type]) {
      var value = record[originalField];

      if (!fieldDefinition) clone[_settings.reservedKeys.meta][field] = value;else clone[_settings.reservedKeys.attributes][field] = value;

      continue;
    }

    // Handle link fields.
    var ids = record[originalField];

    var linkedType = inflectType ? _inflection2.default.pluralize(fieldDefinition[keys.link]) : fieldDefinition[keys.link];

    clone[_settings.reservedKeys.relationships][field] = (_clone$reservedKeys$r = {}, (0, _defineProperty3.default)(_clone$reservedKeys$r, _settings.reservedKeys.links, (_reservedKeys$links = {}, (0, _defineProperty3.default)(_reservedKeys$links, _settings.reservedKeys.self, prefix + uriTemplate.fillFromObject({
      type: inflectType ? _inflection2.default.pluralize(type) : type,
      ids: id,
      relatedField: _settings.reservedKeys.relationships,
      relationship: inflectKeys ? _inflection2.default.transform(field, ['underscore', 'dasherize']) : field
    })), (0, _defineProperty3.default)(_reservedKeys$links, _settings.reservedKeys.related, prefix + uriTemplate.fillFromObject({
      type: inflectType ? _inflection2.default.pluralize(type) : type,
      ids: id,
      relatedField: inflectKeys ? _inflection2.default.transform(field, ['underscore', 'dasherize']) : field
    })), _reservedKeys$links)), (0, _defineProperty3.default)(_clone$reservedKeys$r, _settings.reservedKeys.primary, fieldDefinition[keys.isArray] ? ids.map(toIdentifier.bind(null, linkedType)) : ids ? toIdentifier(linkedType, ids) : null), _clone$reservedKeys$r);
  }

  if (!(0, _keys2.default)(clone[_settings.reservedKeys.attributes]).length) delete clone[_settings.reservedKeys.attributes];

  if (!(0, _keys2.default)(clone[_settings.reservedKeys.meta]).length) delete clone[_settings.reservedKeys.meta];

  if (!(0, _keys2.default)(clone[_settings.reservedKeys.relationships]).length) delete clone[_settings.reservedKeys.relationships];

  return clone;
}

function toIdentifier(type, id) {
  var _ref;

  return _ref = {}, (0, _defineProperty3.default)(_ref, _settings.reservedKeys.type, type), (0, _defineProperty3.default)(_ref, _settings.reservedKeys.id, id.toString()), _ref;
}

function attachQueries(context) {
  var recordTypes = this.recordTypes;
  var keys = this.keys;
  var options = this.options;
  var castValue = this.castValue;
  var BadRequestError = this.errors.BadRequestError;
  var _options2 = this.options;
  var includeLimit = _options2.includeLimit;
  var maxLimit = _options2.maxLimit;
  var request = context.request;
  var type = context.request.type;

  var fields = recordTypes[type];
  var reduceFields = function reduceFields(fields, field) {
    fields[field] = true;
    return fields;
  };
  var castMap = function castMap(type, options, x) {
    return castValue(x, type, options);
  };

  var query = context.request.uriObject.query;

  if (!query) query = {};

  // Iterate over dynamic query strings.
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(query)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var parameter = _step2.value;

      // Attach fields option.
      if (parameter.match(_settings.isField)) {
        var sparseField = query[parameter].split(',');
        var sparseType = (parameter.match(_settings.inBrackets) || [])[1];
        var _fields2 = sparseField.reduce(reduceFields, {});

        if (sparseType === type) request.options.fields = _fields2;else if (sparseType) {
          if (!(sparseType in request.includeOptions)) request.includeOptions[sparseType] = {};

          request.includeOptions[sparseType].fields = _fields2;
        }
      }

      // Attach match option.
      if (parameter.match(_settings.isFilter)) {
        if (!('match' in request.options)) request.options.match = {};
        var field = (parameter.match(_settings.inBrackets) || [])[1];

        if (!(field in fields)) throw new BadRequestError('The field "' + field + '" is non-existent.');

        var fieldType = fields[field][keys.type];
        var value = query[parameter].split(',');

        request.options.match[field] = value.map(castMap.bind(null, fieldType, options));
      }
    }

    // Attach include option.
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (_settings.reservedKeys.include in query) {
    request.include = query[_settings.reservedKeys.include].split(',').map(function (i) {
      return i.split('.').slice(0, includeLimit);
    });

    // Manually expand nested includes.
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator3.default)(request.include), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var path = _step3.value;

        for (var i = path.length - 1; i > 0; i--) {
          var j = path.slice(0, i);
          if (!request.include.some(_deepEqual2.default.bind(null, j))) request.include.push(j);
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  // Attach sort option.
  if (_settings.reservedKeys.sort in query) request.options.sort = query.sort.split(',').reduce(function (sort, field) {
    if (field.charAt(0) === '-') sort[field.slice(1)] = false;else sort[field] = true;
    return sort;
  }, {});

  // Attach offset option.
  if (_settings.pageOffset in query) request.options.offset = Math.abs(parseInt(query[_settings.pageOffset], 10));

  // Attach limit option.
  if (_settings.pageLimit in query) request.options.limit = Math.abs(parseInt(query[_settings.pageLimit], 10));

  // Check limit option.
  var limit = request.options.limit;

  if (!limit || limit > maxLimit) request.options.limit = maxLimit;
}

function mapId(relatedType, link) {
  var ConflictError = this.errors.ConflictError;

  if (link[_settings.reservedKeys.type] !== relatedType) throw new ConflictError('Data object field ' + ('"' + _settings.reservedKeys.type + '" is invalid, it must be ') + ('"' + relatedType + '", not "' + link[_settings.reservedKeys.type] + '".'));

  return castId(link[_settings.reservedKeys.id]);
}

function matchId(object, id) {
  return id === castId(object[_settings.reservedKeys.id]);
}

function castId(id) {
  // Stolen from jQuery source code:
  // https://api.jquery.com/jQuery.isNumeric/
  var float = (0, _parseFloat2.default)(id);
  return id - float + 1 >= 0 ? float : id;
}

function under(s) {
  return s.replace(/-/g, '_');
}

function parseBuffer(payload) {
  var BadRequestError = this.errors.BadRequestError;

  if (!Buffer.isBuffer(payload)) return payload;

  try {
    return JSON.parse(payload.toString());
  } catch (error) {
    throw new BadRequestError('Invalid JSON: ' + error.message);
  }
}