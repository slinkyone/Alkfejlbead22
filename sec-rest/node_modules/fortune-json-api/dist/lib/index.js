'use strict';

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _uriTemplates = require('uri-templates');

var _uriTemplates2 = _interopRequireDefault(_uriTemplates);

var _inflection = require('inflection');

var _inflection2 = _interopRequireDefault(_inflection);

var _settings = require('./settings');

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// JSON API is an highly verbose and ambiguous specification. There are many
// trade-offs made in an attempt to cover everyone's use cases, such as
// resource identifier objects for polymorphic link fields, and relationship
// entities which are an entirely unnecessary complication. More importantly,
// it assumes tight coupling with the API consumer and the HTTP protocol. For
// example, it assumes that the client has *a priori* knowledge of types that
// exist on the server, since it does not define an entry point.
//
// The format is painful to implement and the specification is pretty long,
// I would not recommend doing it yourself unless you're a masochist like me.

module.exports = function (Serializer) {
  return (0, _assign2.default)((function (_Serializer) {
    (0, _inherits3.default)(JsonApiSerializer, _Serializer);

    function JsonApiSerializer() {
      (0, _classCallCheck3.default)(this, JsonApiSerializer);

      var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(JsonApiSerializer).apply(this, arguments));

      var options = _this.options;
      var methods = _this.methods;

      var methodMap = {
        GET: methods.find,
        POST: methods.create,
        PATCH: methods.update,
        DELETE: methods.delete,
        OPTIONS: _this.showAllow.bind(_this)
      };

      // Set options.
      for (var key in _settings.defaults) {
        if (!(key in options)) options[key] = _settings.defaults[key];
      }var uriTemplate = (0, _uriTemplates2.default)((options ? options.uriTemplate : null) || _settings.defaults.uriTemplate);

      (0, _defineProperties2.default)(_this, {

        // Parse the URI template.
        uriTemplate: { value: uriTemplate },

        // Default method mapping.
        methodMap: { value: methodMap },

        // Methods which may accept input.
        inputMethods: { value: new _set2.default([methods.create, methods.update]) }

      });
      return _this;
    }

    (0, _createClass3.default)(JsonApiSerializer, [{
      key: 'processRequest',
      value: function processRequest(context) {
        // If the request was initiated without HTTP arguments, this is a no-op.
        if (arguments.length === 1) return context;

        return _helpers.initializeContext.call(this, context, arguments[1]);
      }
    }, {
      key: 'showAllow',
      value: function showAllow(context) {
        var allowLevel = this.options.allowLevel;
        var uriObject = context.request.uriObject;

        delete uriObject.query;

        var degree = (0, _keys2.default)(uriObject).filter(function (key) {
          return uriObject[key];
        }).length;

        var allow = allowLevel[degree];

        if (allow) context.response.meta.headers['Allow'] = allow.join(', ');

        return context;
      }

      // Ad-hoc entry point implementation.

    }, {
      key: 'showIndex',
      value: function showIndex(context) {
        var recordTypes = this.recordTypes;
        var options = this.options;
        var uriTemplate = this.uriTemplate;
        var inflectType = options.inflectType;
        var prefix = options.prefix;

        var output = (0, _defineProperty3.default)({}, _settings.reservedKeys.links, {});

        for (var type in recordTypes) {
          if (inflectType) type = _inflection2.default.pluralize(type);
          output[_settings.reservedKeys.links][type] = prefix + uriTemplate.fillFromObject({ type: type });
        }

        context.response.payload = output;

        return context;
      }
    }, {
      key: 'showResponse',
      value: function showResponse(context, records, include) {
        var _this2 = this;

        var keys = this.keys;
        var methods = this.methods;
        var uriTemplate = this.uriTemplate;
        var recordTypes = this.recordTypes;
        var _options = this.options;
        var prefix = _options.prefix;
        var inflectType = _options.inflectType;
        var inflectKeys = _options.inflectKeys;
        var NotFoundError = this.errors.NotFoundError;

        if (!records) return this.showIndex(context);

        var _context$request = context.request;
        var method = _context$request.method;
        var type = _context$request.type;
        var ids = _context$request.ids;
        var relatedField = _context$request.relatedField;
        var relationship = _context$request.relationship;
        var originalType = _context$request.originalType;
        var originalIds = _context$request.originalIds;
        var response = context.response;
        var updateModified = context.response.updateModified;

        if (relationship) return this.showRelationship.apply(this, arguments);

        // Handle a not found error.
        if (ids && ids.length && method === methods.find && !relatedField && !records.length) throw new NotFoundError('No records match the request.');

        // Delete and update requests may not respond with anything.
        if (method === methods.delete || method === methods.update && !updateModified) return context;

        var output = {};

        // Show collection.
        if (!ids && method === methods.find) {
          var _Object$assign2;

          var count = records.count;
          var _context$request2 = context.request;
          var query = _context$request2.uriObject.query;
          var _context$request2$opt = _context$request2.options;
          var limit = _context$request2$opt.limit;
          var offset = _context$request2$opt.offset;

          var collection = prefix + uriTemplate.fillFromObject({ query: query,
            type: inflectType ? _inflection2.default.pluralize(type) : type });
          var queryLength = query ? (0, _keys2.default)(query).length : 0;

          output[_settings.reservedKeys.meta] = { count: count };
          output[_settings.reservedKeys.links] = (0, _defineProperty3.default)({}, _settings.reservedKeys.self, collection);
          output[_settings.reservedKeys.primary] = [];

          // Set top-level pagination links.
          if (count > limit) (0, _assign2.default)(output[_settings.reservedKeys.links], (_Object$assign2 = {}, (0, _defineProperty3.default)(_Object$assign2, _settings.reservedKeys.first, '' + collection + (queryLength ? '&' : '?') + (_settings.pageOffset + '=0&' + _settings.pageLimit + '=' + limit)), (0, _defineProperty3.default)(_Object$assign2, _settings.reservedKeys.last, '' + collection + (queryLength ? '&' : '?') + (_settings.pageOffset + '=' + Math.floor((count - 1) / limit) * limit + '&') + (_settings.pageLimit + '=' + limit)), _Object$assign2), limit + (offset || 0) < count ? (0, _defineProperty3.default)({}, _settings.reservedKeys.next, '' + collection + (queryLength ? '&' : '?') + (_settings.pageOffset + '=' + (Math.floor((offset || 0) / limit) + 1) * limit + '&' + _settings.pageLimit + '=' + limit)) : null, (offset || 0) >= limit ? (0, _defineProperty3.default)({}, _settings.reservedKeys.prev, '' + collection + (queryLength ? '&' : '?') + ' ' + (_settings.pageOffset + '=' + (Math.floor((offset || 0) / limit) - 1) * limit + '&' + _settings.pageLimit + '=' + limit)) : null);
        }

        if (records.length) {
          if (ids) output[_settings.reservedKeys.links] = (0, _defineProperty3.default)({}, _settings.reservedKeys.self, prefix + uriTemplate.fillFromObject({
            type: inflectType ? _inflection2.default.pluralize(type) : type,
            ids: ids
          }));

          output[_settings.reservedKeys.primary] = records.map(function (record) {
            return _helpers.mapRecord.call(_this2, type, record);
          });

          if ((!originalType || originalType && !recordTypes[originalType][relatedField][keys.isArray]) && (ids && ids.length === 1 || method === methods.create && records.length === 1)) output[_settings.reservedKeys.primary] = output[_settings.reservedKeys.primary][0];

          if (method === methods.create) response.meta.headers['Location'] = prefix + uriTemplate.fillFromObject({
            type: inflectType ? _inflection2.default.pluralize(type) : type,
            ids: records.map(function (record) {
              return record[keys.primary];
            })
          });
        } else if (relatedField) output[_settings.reservedKeys.primary] = recordTypes[originalType][relatedField][keys.isArray] ? [] : null;

        // Set related records.
        if (relatedField) output[_settings.reservedKeys.links] = (0, _defineProperty3.default)({}, _settings.reservedKeys.self, prefix + uriTemplate.fillFromObject({
          type: inflectType ? _inflection2.default.pluralize(originalType) : originalType,
          ids: originalIds,
          relatedField: inflectKeys ? _inflection2.default.transform(relatedField, ['underscore', 'dasherize']) : relatedField
        }));

        // To show included records, we have to flatten them :(
        if (include) {
          output[_settings.reservedKeys.included] = [];

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(include)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _output$reservedKeys$4;

              var _type = _step.value;

              (_output$reservedKeys$4 = output[_settings.reservedKeys.included]).push.apply(_output$reservedKeys$4, (0, _toConsumableArray3.default)(include[_type].map(_helpers.mapRecord.bind(this, _type))));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        if ((0, _keys2.default)(output).length) response.payload = output;

        return context;
      }
    }, {
      key: 'showRelationship',
      value: function showRelationship(context, records) {
        var _reservedKeys$links;

        var _context$request3 = context.request;
        var method = _context$request3.method;
        var type = _context$request3.type;
        var relatedField = _context$request3.relatedField;
        var originalType = _context$request3.originalType;
        var originalIds = _context$request3.originalIds;
        var keys = this.keys;
        var uriTemplate = this.uriTemplate;
        var recordTypes = this.recordTypes;
        var methods = this.methods;
        var _options2 = this.options;
        var prefix = _options2.prefix;
        var inflectType = _options2.inflectType;
        var inflectKeys = _options2.inflectKeys;
        var BadRequestError = this.errors.BadRequestError;

        if (originalIds.length > 1) throw new BadRequestError('Can only show relationships for one record at a time.');

        if (method !== methods.find) return context;

        var output = (0, _defineProperty3.default)({}, _settings.reservedKeys.links, (_reservedKeys$links = {}, (0, _defineProperty3.default)(_reservedKeys$links, _settings.reservedKeys.self, prefix + uriTemplate.fillFromObject({
          type: inflectType ? _inflection2.default.pluralize(originalType) : originalType,
          ids: originalIds, relatedField: _settings.reservedKeys.relationships,
          relationship: inflectKeys ? _inflection2.default.transform(relatedField, ['underscore', 'dasherize']) : relatedField
        })), (0, _defineProperty3.default)(_reservedKeys$links, _settings.reservedKeys.related, prefix + uriTemplate.fillFromObject({
          type: inflectType ? _inflection2.default.pluralize(originalType) : originalType,
          ids: originalIds,
          relatedField: inflectKeys ? _inflection2.default.transform(relatedField, ['underscore', 'dasherize']) : relatedField
        })), _reservedKeys$links));

        var isArray = recordTypes[originalType][relatedField][keys.isArray];
        var identifiers = records.map(function (record) {
          var _ref3;

          return _ref3 = {}, (0, _defineProperty3.default)(_ref3, _settings.reservedKeys.type, inflectType ? _inflection2.default.pluralize(type) : type), (0, _defineProperty3.default)(_ref3, _settings.reservedKeys.id, record[keys.primary]), _ref3;
        });

        output[_settings.reservedKeys.primary] = isArray ? identifiers : identifiers.length ? identifiers[0] : null;

        context.response.payload = output;

        return context;
      }
    }, {
      key: 'parseCreate',
      value: function parseCreate(context) {
        var _this3 = this;

        context.request.payload = _helpers.parseBuffer.call(this, context.request.payload);

        var keys = this.keys;
        var recordTypes = this.recordTypes;
        var options = this.options;
        var castValue = this.castValue;
        var _options3 = this.options;
        var inflectType = _options3.inflectType;
        var inflectKeys = _options3.inflectKeys;
        var _errors = this.errors;
        var MethodError = _errors.MethodError;
        var BadRequestError = _errors.BadRequestError;
        var ConflictError = _errors.ConflictError;
        var _context$request4 = context.request;
        var payload = _context$request4.payload;
        var relatedField = _context$request4.relatedField;
        var type = _context$request4.type;
        var ids = _context$request4.ids;

        var fields = recordTypes[type];
        var cast = function cast(type, options) {
          return function (value) {
            return castValue(value, type, options);
          };
        };

        // Can not create with IDs specified in route.
        if (ids) throw new MethodError('Can not create with ID in the route.');

        // Can not create if related records are specified.
        if (relatedField) throw new MethodError('Can not create related record.');

        if (!payload) throw new BadRequestError('Payload is missing.');

        var data = payload[_settings.reservedKeys.primary];

        // No bulk extension for now.
        if (Array.isArray(data)) throw new BadRequestError('Data must be singular.');

        data = [data];

        return data.map(function (record) {
          var clone = {};
          var recordType = inflectType ? _inflection2.default.singularize(record[_settings.reservedKeys.type]) : record[_settings.reservedKeys.type];

          if (recordType !== type) throw new ConflictError('Incorrect type.');

          if (_settings.reservedKeys.id in record) clone[_settings.reservedKeys.id] = (0, _helpers.castId)(record[_settings.reservedKeys.id]);

          if (_settings.reservedKeys.attributes in record) for (var field in record[_settings.reservedKeys.attributes]) {
            var value = record[_settings.reservedKeys.attributes][field];
            var fieldDefinition = fields[field] || {};
            var fieldType = fieldDefinition[keys.type];

            if (inflectKeys) field = _inflection2.default.camelize((0, _helpers.under)(field), true);

            clone[field] = Array.isArray(value) ? value.map(cast(fieldType, options)) : castValue(value, fieldType, options);
          }

          if (_settings.reservedKeys.relationships in record) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(record[_settings.reservedKeys.relationships])), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var field = _step2.value;

                var value = record[_settings.reservedKeys.relationships][field];

                if (inflectKeys) field = _inflection2.default.camelize((0, _helpers.under)(field), true);

                if (!(_settings.reservedKeys.primary in value)) throw new BadRequestError('The ' + ('"' + _settings.reservedKeys.primary + '" field is missing.'));

                var relatedType = inflectType ? _inflection2.default.pluralize(fields[field][keys.link]) : fields[field][keys.link];
                var relatedIsArray = fields[field][keys.isArray];
                var _data = value[_settings.reservedKeys.primary];

                clone[field] = _data ? (Array.isArray(_data) ? _data : [_data]).map(_helpers.mapId.bind(_this3, relatedType)) : null;

                if (clone[field] && !relatedIsArray) clone[field] = clone[field][0];
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }return clone;
        });
      }
    }, {
      key: 'parseUpdate',
      value: function parseUpdate(context) {
        context.request.payload = _helpers.parseBuffer.call(this, context.request.payload);

        var recordTypes = this.recordTypes;
        var keys = this.keys;
        var options = this.options;
        var castValue = this.castValue;
        var _options4 = this.options;
        var inflectType = _options4.inflectType;
        var inflectKeys = _options4.inflectKeys;
        var _errors2 = this.errors;
        var MethodError = _errors2.MethodError;
        var BadRequestError = _errors2.BadRequestError;
        var ConflictError = _errors2.ConflictError;
        var _context$request5 = context.request;
        var payload = _context$request5.payload;
        var type = _context$request5.type;
        var ids = _context$request5.ids;
        var relatedField = _context$request5.relatedField;
        var relationship = _context$request5.relationship;

        var cast = function cast(type, options) {
          return function (value) {
            return castValue(value, type, options);
          };
        };

        if (relationship) return this.updateRelationship.apply(this, arguments);

        // No related record update.
        if (relatedField) throw new MethodError('Can not update related record indirectly.');

        // Can't update collections.
        if (!Array.isArray(ids) || !ids.length) throw new BadRequestError('IDs unspecified.');

        if (!payload) throw new BadRequestError('Payload is missing.');

        var fields = recordTypes[type];
        var updates = [];
        var data = payload[_settings.reservedKeys.primary];

        // No bulk/patch extension for now.
        if (Array.isArray(data)) throw new BadRequestError('Data must be singular.');

        data = [data];

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = (0, _getIterator3.default)(data), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var update = _step3.value;

            var replace = {};
            var updateType = inflectType ? _inflection2.default.singularize(update[_settings.reservedKeys.type]) : update[_settings.reservedKeys.type];

            if (!ids.some(_helpers.matchId.bind(null, update))) throw new ConflictError('Invalid ID.');

            if (updateType !== type) throw new ConflictError('Incorrect type.');

            if (_settings.reservedKeys.attributes in update) for (var field in update[_settings.reservedKeys.attributes]) {
              var value = update[_settings.reservedKeys.attributes][field];
              var fieldDefinition = fields[field] || {};
              var fieldType = fieldDefinition[keys.type];

              if (inflectKeys) field = _inflection2.default.camelize((0, _helpers.under)(field), true);

              replace[field] = Array.isArray(value) ? value.map(cast(fieldType, options)) : castValue(value, fieldType, options);
            }

            if (_settings.reservedKeys.relationships in update) {
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = (0, _getIterator3.default)((0, _keys2.default)(update[_settings.reservedKeys.relationships])), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var field = _step4.value;

                  var value = update[_settings.reservedKeys.relationships][field];

                  if (inflectKeys) field = _inflection2.default.camelize((0, _helpers.under)(field), true);

                  if (!(_settings.reservedKeys.primary in value)) throw new BadRequestError('The ' + ('"' + _settings.reservedKeys.primary + '" field is missing.'));

                  var relatedType = inflectType ? _inflection2.default.pluralize(fields[field][keys.link]) : fields[field][keys.link];
                  var relatedIsArray = fields[field][keys.isArray];
                  var _data2 = value[_settings.reservedKeys.primary];

                  replace[field] = _data2 ? (Array.isArray(_data2) ? _data2 : [_data2]).map(_helpers.mapId.bind(this, relatedType)) : null;

                  if (replace[field] && !relatedIsArray) replace[field] = replace[field][0];
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }
            }updates.push({
              id: (0, _helpers.castId)(update[_settings.reservedKeys.id]),
              replace: replace
            });
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        if (updates.length < ids.length) throw new BadRequestError('An update is missing.');

        return updates;
      }
    }, {
      key: 'updateRelationship',
      value: function updateRelationship(context) {
        var recordTypes = this.recordTypes;
        var keys = this.keys;
        var methods = this.methods;
        var inflectType = this.options.inflectType;
        var _errors3 = this.errors;
        var NotFoundError = _errors3.NotFoundError;
        var MethodError = _errors3.MethodError;
        var BadRequestError = _errors3.BadRequestError;
        var ConflictError = _errors3.ConflictError;
        var _context$request6 = context.request;
        var payload = _context$request6.payload;
        var type = _context$request6.type;
        var relatedField = _context$request6.relatedField;
        var originalMethod = _context$request6.originalMethod;
        var originalType = _context$request6.originalType;
        var originalIds = _context$request6.originalIds;

        var isArray = recordTypes[originalType][relatedField][keys.isArray];

        if (originalIds.length > 1) throw new NotFoundError('Can only update relationships for one record at a time.');

        if (!isArray && originalMethod) throw new MethodError('Can not ' + originalMethod === methods.create ? 'push to' : 'pull from' + ' a to-one relationship.');

        var updates = [];
        var operation = originalMethod ? originalMethod === methods.create ? 'push' : 'pull' : 'replace';
        var updateIds = payload[_settings.reservedKeys.primary];

        if (!isArray) if (!Array.isArray(updateIds)) updateIds = [updateIds];else throw new BadRequestError('Data must be singular.');

        updateIds = updateIds.map(function (update) {
          var updateType = inflectType ? _inflection2.default.singularize(update[_settings.reservedKeys.type]) : update[_settings.reservedKeys.type];

          if (updateType !== type) throw new ConflictError('Incorrect type.');

          if (!(_settings.reservedKeys.id in update)) throw new BadRequestError('ID is unspecified.');

          return (0, _helpers.castId)(update[_settings.reservedKeys.id]);
        });

        updates.push((0, _defineProperty3.default)({
          id: originalIds[0]
        }, operation, (0, _defineProperty3.default)({}, relatedField, isArray ? updateIds : updateIds[0])));

        // Rewrite type and IDs.
        context.request.type = originalType;
        context.request.ids = null;

        return updates;
      }
    }, {
      key: 'showError',
      value: function showError(context, error) {
        var MethodError = this.errors.MethodError;
        var _error = error;
        var name = _error.name;
        var message = _error.message;

        if (error.constructor === MethodError) this.showAllow(context);

        error = (0, _assign2.default)({}, name ? { title: name } : null, message ? { detail: message } : null, error);

        context.response.payload = (0, _defineProperty3.default)({}, _settings.reservedKeys.errors, [error]);

        return context;
      }
    }]);
    return JsonApiSerializer;
  })(Serializer), { id: _settings.mediaType });
};