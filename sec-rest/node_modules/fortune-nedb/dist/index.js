'use strict';

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _nedb = require('nedb');

var _nedb2 = _interopRequireDefault(_nedb);

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// By default, try to auto-compact the database every minute.
var defaultCompactionInterval = 60 * 1000;

/**
 * NeDB adapter.
 */
module.exports = function (Adapter) {
  return (function (_Adapter) {
    (0, _inherits3.default)(NedbAdapter, _Adapter);

    function NedbAdapter() {
      (0, _classCallCheck3.default)(this, NedbAdapter);
      return (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(NedbAdapter).apply(this, arguments));
    }

    (0, _createClass3.default)(NedbAdapter, [{
      key: 'connect',
      value: function connect() {
        var _this2 = this;

        var recordTypes = this.recordTypes;
        var options = this.options;
        var _options = this.options;
        var compactionInterval = _options.compactionInterval;
        var dbPath = _options.dbPath;

        delete options.filename;

        try {
          this.db = (0, _helpers.mapValues)(recordTypes, function (fields, type) {
            var db = new _nedb2.default((0, _assign2.default)({}, options, dbPath ? {
              filename: _path2.default.join(dbPath, type + '.db')
            } : null));
            db.persistence.setAutocompactionInterval(compactionInterval ? compactionInterval : defaultCompactionInterval);
            return db;
          });
        } catch (error) {
          return _promise2.default.reject(error);
        }

        return _promise2.default.all((0, _keys2.default)(this.db).map(function (type) {
          return new _promise2.default(function (resolve, reject) {
            return _this2.db[type].loadDatabase(function (error) {
              return error ? reject(error) : resolve();
            });
          });
        })).then(function () {
          return null;
        });
      }
    }, {
      key: 'disconnect',
      value: function disconnect() {
        var _this3 = this;

        return _promise2.default.all((0, _keys2.default)(this.db).map(function (key) {
          return new _promise2.default(function (resolve) {
            var db = _this3.db[key];

            // This auto compaction interval prevents the process from exiting.
            db.persistence.stopAutocompaction();

            // Internal hook to NeDB's executor which will run after all other
            // operations are done.
            db.executor.push({ fn: resolve, arguments: [] });
          });
        })).then(function () {
          return null;
        });
      }
    }, {
      key: 'find',
      value: function find(type, ids, options) {
        var _this4 = this;

        // Handle no-op.
        if (ids && !ids.length) return (0, _get3.default)(Object.getPrototypeOf(NedbAdapter.prototype), 'find', this).call(this);
        if (!options) options = {};

        var query = {};

        try {
          if ('match' in options) (0, _assign2.default)(query, (0, _helpers.mapValues)(options.match, function (value) {
            return Array.isArray(value) ? { $in: value.map(_helpers.castValue) } : (0, _helpers.castValue)(value);
          }));

          if ('query' in options) (0, _assign2.default)(query, options.query);

          if (ids && ids.length) query[_helpers.idKey] = { $in: ids };
        } catch (error) {
          return _promise2.default.reject(error);
        }

        // Parallelize the find method with count method.
        return _promise2.default.all([new _promise2.default(function (resolve, reject) {
          var _db$type;

          var args = [query];

          if ('fields' in options) args.push((0, _helpers.mapValues)(options.fields, function (value) {
            return value ? 1 : 0;
          }));

          var find = (_db$type = _this4.db[type]).find.apply(_db$type, args);

          if ('sort' in options) find.sort((0, _helpers.mapValues)(options.sort, function (value) {
            return value ? 1 : -1;
          }));

          if ('offset' in options) find.skip(options.offset);

          if ('limit' in options) find.limit(options.limit);

          find.exec(function (error, records) {
            return error ? reject(error) : resolve(records.map(_helpers.outputRecord.bind(_this4, type)));
          });
        }), new _promise2.default(function (resolve, reject) {
          return _this4.db[type].count(query, function (error, count) {
            return error ? reject(error) : resolve(count);
          });
        })]).then(function (results) {
          // Set the count on the records array.
          results[0].count = results[1];
          return results[0];
        });
      }
    }, {
      key: 'create',
      value: function create(type, records) {
        var _this5 = this;

        var ConflictError = this.errors.ConflictError;

        return new _promise2.default(function (resolve, reject) {
          return _this5.db[type].insert(records.map(_helpers.inputRecord.bind(_this5, type)), function (error, result) {
            return error ? reject(error.errorType === 'uniqueViolated' ? new ConflictError('Duplicate key.') : error) : resolve(result.map(_helpers.outputRecord.bind(_this5, type)));
          });
        });
      }
    }, {
      key: 'update',
      value: function update(type, updates) {
        var _this6 = this;

        var keys = this.keys;

        return _promise2.default.all(updates.map(function (update) {
          return new _promise2.default(function (resolve, reject) {
            var modifiers = {};

            if ('replace' in update) modifiers.$set = update.replace;

            if ('push' in update) modifiers.$push = (0, _helpers.mapValues)(update.push, function (value) {
              return Array.isArray(value) ? { $each: value } : value;
            });

            if ('pull' in update) modifiers.$pull = (0, _helpers.mapValues)(update.pull, function (value) {
              return Array.isArray(value) ? { $in: value } : value;
            });

            // Custom update operators have precedence.
            (0, _assign2.default)(modifiers, update.operate);

            // Short circuit no-op.
            if (!(0, _keys2.default)(modifiers).length) return resolve(0);

            _this6.db[type].update((0, _defineProperty3.default)({}, _helpers.idKey, update[keys.primary]), modifiers, {}, function (error, number) {
              return error ? reject(error) : resolve(number);
            });
          });
        })).then(function (numbers) {
          return numbers.reduce(function (accumulator, number) {
            return accumulator + number;
          }, 0);
        });
      }
    }, {
      key: 'delete',
      value: function _delete(type, ids) {
        var _this7 = this;

        if (ids && !ids.length) return (0, _get3.default)(Object.getPrototypeOf(NedbAdapter.prototype), 'delete', this).call(this);

        return new _promise2.default(function (resolve, reject) {
          return _this7.db[type].remove(ids && ids.length ? (0, _defineProperty3.default)({}, _helpers.idKey, { $in: ids }) : {}, { multi: true }, function (error, number) {
            return error ? reject(error) : resolve(number);
          });
        });
      }
    }]);
    return NedbAdapter;
  })(Adapter);
};